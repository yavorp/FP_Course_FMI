## Можете да ползвате която и да е функция оттук, за да имплементирате която и да е друга.
(както обикновено)


## 00. (2т.) `group`

Групира съседните елементи на даден списък, които са равни един на друг, в списъци.
```haskell
group :: Eq a => [a] -> [[a]]
```

Примери:
```haskell
> group []
[]
> group [69]
[[69]]
> group [1,2,3]
[[1],[2],[3]]
> group [1,1,2,1,3,1,3,3,2,1,2,2]
[[1,1],[2],[1],[3],[1],[3,3],[2],[1],[2,2]]
```

## 01. (1т.) `sortBy`

Сортира списък по подадена наредба.

Няма значение точно кой алгоритъм ще изберете за сортирането.

(лично за мен най-лесно тук е с insertion sort)
```haskell
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
```

Типът `Ordering` [е дефиниран](https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Ordering) по следния начин:
```haskell
data Ordering = LT | EQ | GT
```

Ще искаме той да означава "резултат от сравнение на две неща".
Функцията `compare` от типовия клас `Ord` връща `Ordering`.

Примери за `compare`:
```haskell
> compare 5 10
LT
> compare 5 5
EQ
> compare 5 3
GT
> compare False True
LT
> compare True False
GT
> compare True True
EQ
> compare EQ EQ
EQ
> compare LT GT
LT
> compare 'a' 'b'
LT
> compare 'a' 'A'
GT
```

Примери за `sortBy`:
```haskell
> sortBy compare [10,9..1]
[1,2,3,4,5,6,7,8,9,10]
> sortBy (\_ _ -> EQ) [5,1,3,4,1,2,4]
[5,1,3,4,1,2,4]
> sortBy (flip compare) [1..10]
[10,9,8,7,6,5,4,3,2,1]
> sortBy (\x y -> if x < y then LT else if x == y then EQ else GT) [1,2,31,3,1,2,1]
[1,1,1,2,2,3,31]
> sortBy (\x y -> odd x `compare` odd y) [1..10]
[2,4,6,8,10,1,3,5,7,9]
```

## 02. (1т.) `groupBy`

Като `group`, но взима предикат който да казва дали два елемента са "равни".

Очаква се подадените предикати към `groupBy` да са [релации на еквивалентност](https://en.wikipedia.org/wiki/Equivalence_relation).

Ще срещнете случай(/и) в рекурсията си, който не би трябвало да е възможен,
ако `groupBy` е имплементирана правилно.

Там е ок да сложите `error "The impossible has happened"`.

Бонусът към това домашно се отнася към това как да **"докажем"**, че този случай е невъзможен
и да разкараме `error`-а.

```haskell
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
```
Примери:

```haskell
> groupBy (==) []
[]
> groupBy (==) [1,1,2,1]
[[1,1],[2],[1]]
> groupBy (\x y -> even x == even y) [1..10]
[[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
> groupBy (\x y -> even x == even y) [1,3,2,4,5]
[[1,3],[2,4],[5]]
> groupBy ((==) `on` odd) [1,3,2,4,5,7,10]
[[1,3],[2,4],[5,7],[10]]
> groupBy ((==) `on` (`rem` 3)) [1,3,2,4,5,7,10] -- compare numbers modulo 3
[[1],[3],[2],[4],[5],[7,10]]
```
Функцията `on` е от следващата задача (но сме я реализирали и в час)


## 03.00. (0т. - HINT) `on`
Прилага функция на два аргумента, като първо прекарва всеки аргумент
през предварителна обработка.

```haskell
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
```
Примери:
```haskell
> on (+) succ 0 1
3
> ((&&) `on` even) 2 4
True
> ((||) `on` even) 3 4
True
> ((||) `on` even) 3 5
False
> (compare `on` even) 3 5
EQ
> (compare `on` even) 3 6
LT
> (compare `on` (`rem` 3)) 4 13
EQ
> (compare `on` (`rem` 3)) 4 15
GT
> (compare `on` (`rem` 3)) 4 14
LT
```

## 03.01. (0т. - HINT) `(&&&)`
Функция, предназначена главно за удобство.
Прави наредена двойка от резултатие на две функции, приложени върху един и същ аргумент.

```haskell
(&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
```
Примери:
```haskell
> (succ &&& (*10)) 12
(13,120)
> (id &&& even) 12
(12,True)
> ((`div` 7) &&& (`rem` 7)) 42
(6,0)
```

## 04. (2т.) `sortOn`

Сортира списък, като ползва функция за трансформация и наредбата
над резултата на функцията.

Няма значение точно кой алгоритъм ще изберете за сортирането.

Опитайте се да реализирате функцията по такъв начин, че за всеки елемент на входящия списък,
входящата функция се прилага **само веднъж**. Това ще е предимство на тази функция над `sortBy`.
```haskell
sortOn :: Ord b => (a -> b) -> [a] -> [a]
```

Примери:
```haskell
> sortOn id [1..5]
[1,2,3,4,5]
> sortOn even [1..10]
[1,3,5,7,9,2,4,6,8,10]
> sortOn (`rem` 5) [1..20]
[5,10,15,20,1,6,11,16,2,7,12,17,3,8,13,18,4,9,14,19]

-- cool example
> data Down a = Down a deriving Eq
> instance Ord a => Ord (Down a) where compare (Down x) (Down y) = compare y x
> sortOn Down [1..10]
[10,9,8,7,6,5,4,3,2,1]
> sortOn Down ['A'..'z']
"zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA"
> sortOn (Down . Down) [1..10]
[1,2,3,4,5,6,7,8,9,10]
```

## 05. (2т.) `groupOn`
Като `group`, но ползва функция за трансформация и равенството над резултата на функцията.

Опитайте се да реализирате функцията по такъв начин, че за всеки елемент на входящия списък,
входящата функция се прилага **само веднъж**. Това ще е предимство на тази функция над `groupBy`.
```haskell
groupOn :: Eq b => (a -> b) -> [a] -> [[a]]
```

Примери:
```haskell
> groupOn id [1,1,2,1,2,3,3,1]
[[1,1],[2],[1],[2],[3,3],[1]]
> groupOn even [1,1,2,4,1,2,3,3,1]
[[1,1],[2,4],[1],[2],[3,3,1]]
> groupOn (`rem` 3) [5,12,15,13,14,15,18,17,18,21,19]
[[5],[12,15],[13],[14],[15,18],[17],[18,21],[19]]
```

## 06. (2т.) `classifyOn`
"Класифицира" елементите на списък по равенството им по подадена трансформация, или казано на български:

Връща списък от класовете на еквивалентност на входния списък, относно равенството под дадена трансформация.

Редът в който ще връщате класовете на еквивалентност няма значение
(и това (би трябвало) да е отразено и в тестовете).

Може да пробвате да го направита и с `Eq b` вместо `Ord b`
```haskell
classifyOn :: Ord b => (a -> b) -> [a] -> [[a]]
```

Примери:
```haskell
> classifyOn even [1..20] -- класификация по четност
[[1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20]]
> classifyOn (==5) [1..10] -- тези които са равни на 5
[[1,2,3,4,6,7,8,9,10],[5]]
> classifyOn (`compare` 5) [1..10] -- тук вече имаме повече от два класа
[[1,2,3,4],[5],[6,7,8,9,10]]
> import Data.Char
> classifyOn isUpper ['A'..'z']
["[\\]^_`abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ"]
> classifyOn (`rem` 3) [1..10] -- класификация по остатък при деление на 3
[[3,6,9],[1,4,7,10],[2,5,8]]
```

## 07. (5т.) Бонус - Гарантирано непразни групи

Имплементирайте еквиваленти на `group{,On,By}` и `classifyOn` със следните типове:
```haskell
groupNonEmpty :: Eq a => [a] -> [NonEmpty a]
groupByNonEmpty :: (a -> a -> Bool) -> [a] -> [NonEmpty a]
groupOnNonEmpty :: Eq b => (a -> b) -> [a] -> [NonEmpty a]
classifyOnNonEmpty :: Ord b => (a -> b) -> [a] -> [NonEmpty a]
```

Където `NonEmpty` представлява следното нещо:
```haskell
data NonEmpty a = a :| [a]
```
Има един конструктор `(:|)`, който взима стойност от тип `a` и списък от `a`-та.

По този начин си гарантираме, че ако имаме нещо от тип `NonEmpty a`, то със сигурност
имаме поне една стойност от типа `a`. Така изразяваме "непразен списък".

Това ще ни позволи да разкараме `error` извикванията от горните функции и съответно
за да вземете бонуса трябва да не се извиква транзитивно(!) никъде `undefined/error` в тях.
(с други думи трябва да са тотални функции)

Възможно е да ви е полезно да си имплементирате и
```haskell
mapNonEmpty :: (a -> b) -> NonEmpty a -> NonEmpty b
```

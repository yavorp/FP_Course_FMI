# "Изкуствен интелект" за морски шах

## 00. (5т.) `(winner b)`
`(winner b)` взима дъска `b` и връща кой е победител на тази дъска.

Примери:

```scheme
(winner '((#f #f #f)
          (#f #f #f)
          (#f #f #f))) ;-- #f

(winner '(("X" "O" "X")
          ("O" "X" "O")
          ("X" "O" "X"))) ;-- "X"

(winner '(("O" "O" "O")
          ("X" "X" #f)
          (#f #f "X"))) ;-- "O"

(winner '(("O" #f "O")
          (#f "O" #f)
          ("X" "X" "X"))) ;-- "X"

(winner '(("X" "O" "O")
          ("O" "X" "O")
          ("O" "X" "X"))) ;-- "X"

(winner '(("X" "O" "X")
          ("O" "X" "O")
          ("O" "X" "O"))) ;-- "D"

(winner '(("X" "O" "X")
          ("O" "O" "X")
          ("O" "X" #f))) ;-- #f
```

## 01. (15т.) `(play curr-board curr-sign)`
`play` взима дъска `curr-board` и знак `curr-sign`- знакът който е на ход сега.

Функцията връща къде да бъде игран ход, като наредена двойка от два индекса в дъската ни

## Описание на `minmax` алгоритъма
Ето **[тук][minmax]** има описание на алгоритъма. Това е алгоритъм който за морски шах дава "перфектна" стратегия -
такава, която винаги води до или победа, или равенство.

Това каква е дъската в момента и кой играе е цялата информация която определя сегашното "състояние" на играта.

Идеята е следната – ще оценим всички дъски (тоест състояния) на морски шах с някакво число,
индикиращо колко е "добро" всяко състояние за нас - по-голямо число == по-добре за нас.

Тъй като в тази игра има само три изхода (и ние няма да се интересуваме от някакви евристики) ще дадем само три оценки – `-1` `0` `1`.

Ако играта беше по-сложна (например нямаме винаги печеливша стратегия, бихме използвали друга схема за оценяване).

За да преценим колко е добро дадено състояние за нас ще подходим по следния начин:

0. В сегашното състояние играта или е приключила (според `winner`), или не е.

    1. Ако играта е приключила оценяваме дъската с:
        * `-1`, ако сме загубили
        * `0`, ако сме наравно
        * `1`, ако сме спечелили
    2. Ако играта не е приключила, то тогава трябва да играем някъде.
        Трябва да решим къде да играем - кое е полето с най-висока стойност за нас, т.е. трябва да оценим
        колко "добро" би било всяко възможно поле за нас, ако играем на него.

        За всяко свободно поле `(x . y)` от сегашното ни състояние
        можем да генерираме нова дъска (ново състояние), поставяйки на `(x . y)` нашия знак.

        [*] Ако можем някак да оценим всяко ново състояние, можем да изберем това с **максимална** стойност
        от тях и да играем на него - знаем че там ще е най-добре за нас.

        Сега въпросът е как да оценим всяко от тези нови състояния.
        В тях на ход ще е противникът ни, т.е. трябва да разберем къде би играл той.

        Понеже целим да играем перфектно трябва да покрием всички възможности.
        За тази цел е достатъчно да сме песимистични и да допуснем че противникът ни също играе перфектно.

        Как да разберем къде би играл той ако играеше перфектно?
        Ами "лесно" - вече имаме процедура която симулира точно това - именно алгоритъма който имплементираме в момента.

        Тоест `goto 0.`. Това което е различно обаче, е че сега ще играем "от гледната точка" на противника.
        Понеже за нас най-високата (**максималната**) стойност на дадена дъска е най-хубава,
        това означава че за противника най-ниската (**минималната**) стойност на дадена дъска ще е най-хубава.

        Трябва да съобразим това докато изпълняваме алгоритъма, взимайки **минималната** стойност на стъпката [*],
        в която сме играли ход и се опитваме да преценим колко е добър този ход. .

        По този начин можем рекурсивно да редуваме **максимизиране** и **минимизиране**
        на стойностите на ходовете, докато не се стигне до дъска, която `winner` може да оцени.
        (такава ще стигнем със сигурност, защото дъската е крайна - дъното на рекурсията ни)


## Примерни изпълнения на алгоритъма
За (мое) улеснение празните места ще индикирам с `_`.

### 00.
Играем с "X".

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**_**|**_**|**X**|

Тази дъска се оценява до `1`, защото сме спечелили (по диагонала).

### 01.
Играем с "O".

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**_**|**_**|**X**|

Тази дъска се оценява до `-1`, защото противникът ни е спечелил (по диагонала).

### 02.
Играем с "X".

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**X**|**X**|**O**|

Тази дъска се оценява до `0`, защото никой не е спечелил.

### 03.
Играем с "X"

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**_**|**_**|**_**|

За тази дъска има три възможни позиции на които да играем.

Те се оценяват до:
* `a)` - `1`
* `b)` - `-1`
* `c)` - `-1`

Тъй като играем от наша гледна точка в момента избираме най-голямата
от стойностите на `a)` `b)` и `c)`, което е `a)` и съответно играем ход `(2 . 0)`.

Сега ще опишем (рекурсивно) как се стига до оценката на всяко от `a)`, `b)`, `c)`.

#### a) `(2 . 0)` - оценява се до `1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**X**|**_**|**_**|

Поставяме "X" на `(2 . 0)` и питаме какво би играл противникът ни.

Но опитвайки се да изпълним алгоритъма от противникове гледна точка, виждаме че
"X" печели на тази дъска и съответно даваме оценка `1` на дъската.

#### b) `(2 . 1)` - оценява се до `-1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**_**|**X**|**_**|

Поставяме "X" на `(2 . 1)` и питаме какво би играл противникът ни.

Опитваме се да изпълним алгоритъма от противникове гледна точка.

Играта не е приключила, следователно трябва да изпробваме всички негови ходове. Те са 2.

Резултатът от ход `b.α)` е `-1`, а пък резултатът от ход `b.β)` е `1`.

Тъй като играем от гледната точка на противника ни в момента,
избираме най-малкото от тези две за стойността на `b)` - `-1`.

#### b.α) `(2 . 0)` - оценява се до `-1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**O**|**X**|**_**|

Поставяме "O" на `(2 . 0)` и питаме какво бихме играли ние.

Виждаме че играта е приключила със загуба за нас.

#### b.β) `(2 . 2)` - оценява се до `1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**_**|**X**|**O**|

Поставяме "O" на `(2 . 2)` и питаме какво бихме играли ние.

Опитваме се да изпълним алгоритъма от наша гледна точка. Играта не е приключила,
следователно трябва да изпробваме всички наши ходове.

Той е един - пробвайки да го изпълним и в последствие да играем от противникова гледна точка,
виждаме че играта е приключила с победа за нас. (това не е разписано за краткота).

#### c) `(2 . 2)` - се оценява до `-1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**_**|**_**|**X**|

Поставяме "X" на `(2 . 2)` и питаме какво би играл противникът ни.

Опитваме се да изпълним алгоритъма от противникова гледна точка.

Играта не е приключила, следователно трябва да изпробваме всички негови ходове. Те са 2.

Резултатът от ход `c.α)` е `-1`, а пък резултатът от ход `c.β)` е `-1`.

Тъй като играем от гледната точка на противника ни в момента,
избираме най-малкото от тези две за стойността на `c)` - `-1`.

В този случай има две с еднаква стойност - няма значение кой от двета хода ще изберем,
затова избираме например "най-първия", т.е. `c.α)`.

#### c.α) `(2 . 0)` - се оценява до `-1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**O**|**_**|**X**|

Поставяме "O" на `(2 . 0)` и питаме какво бихме играли ние

Виждаме че играта е приключила със загуба за нас.

#### c.β) `(2 . 1)` - се оценява до `-1`

|**X**|**O**|**O**|
|-----|-----|-----|
|**X**|**O**|**X**|
|**_**|**O**|**X**|

Поставяме "O" на `(2 . 1)` и питаме какво бихме играли ние

Виждаме че играта е приключила със загуба за нас.

## 02. (5т.) Бонус - Имплементирайте и [алфа-бета отсичане]

## Hints
Тъй като съм наясно че задачата е сравнително по-тежка ще ви дам стъпките през които аз минах,
за да имплементирам алгоритъма.

### Disclaimer: Съдържанието по-надолу е може би _твърде_ подробно и може да развали забавлението ви със задачата. Силно препоръчвам да се пробвате по-усилено първо сами.

00. `(empty-spots xss)`

    Взима дъска `xss` и връща списък от наредени двойки индексите на незапълнените позиции. Това ще е функцията, която ни дава възможните позиций, от сегашната.

    Примери:

    ```scheme
    (empty-spots '(("X" "O" "X")
                   ("X" "O" "O")
                   ("O" "X" "X"))) ;-- '()

    (empty-spots '((#f  "O" "X")
                   ("X" "O" "O")
                   ("O" "X" "X"))) ;-- '((0 . 0))

    (empty-spots '((#f  "O" "X")
                   ("X" "O" "O")
                   ("O" #f  "X"))) ;-- '((0 . 0) (2 . 1))
    ```

    За реализацията на тази функция може да ви е полезно да имате "индексна матрица" –
    на `i` `j`-тия индекс на матрицата, седи наредената двойка `(i . j)`.

01. `(grade win me)`

    Взима победител `win` и кой играч съм аз `me` (#t за "X", #f за "O") и връща колко точки трябва да се дадат за този победител.

    Примери:

    ```scheme
    (grade "D" #t) ;-- 0

    (grade "D" #f) ;-- 0

    (grade "X" #f) ;-- -1

    (grade "X" #t) ;-- 1

    (grade "O" #f) ;-- 1

    (grade "O" #t) ;-- -1
    ```

02. `(maximum-on f xs)`

    Взима функция `f`, която да приложи върху елементите на списъка `xs`, преди да избере този от тях, с най-голяма стойност след приложението на функцията.

    Примери:

    ```scheme
    (maximum-on id '(1 2 3)) ;-- 3

    (maximum-on (lambda (x) (-x)) '(1 2 3)) ;-- 1

    (maximum-on car '((1 . 1337) (0 . 20000) (10 . 4))) ;-- (10 . 4)

    (maximum-on cdr '((1 . 1337) (0 . 20000) (10 . 4))) ;-- (0 . 20000)
    ```

03. `(maximise board curr-player me)` и `(minimise board curr-player me)`

    Функциите, които реално реализират оценявато на една дъска `board`, като взимат
    кой играе сега на ход `curr-player` и от коя гледна точка `me` (`#t` или `#f` отново) се оценява дъската.

    Те са реално дуални, като единствено се различават по какво сравнение правят
    (`max` vs `min`).

    Идеята в тях е да видим дали сме ударили дъно, след което ако не сме
    да продължим рекурсията си надолу, извиквайки дуалната на сегашната (за да отразим факта, че на следващия ход играе другият играч).

    След като ги напишете много бързо ще видите че може и да е една функция, с малко абстрахиране.


[minmax]: https://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
[алфа-бета отсичане]: https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning

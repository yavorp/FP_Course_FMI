# Библиотека за матрици

## 00. `(all? p? xs)`
Проверява дали всички елементи на `xs` изпълняват предиката `p?`.

Примери:
```scheme
(all? even? '(2 4 6))   ;-- #t
(all? even? '(1 2 4 6)) ;-- #f
(all? even? '())        ;-- #t
```

## 01. `(any? p? xs)`
Проверява дали има елемент на `xs`, който изпълнява предиката `p?`.

Примери:
```scheme
(any? even? '(1 2 4 6)) ;-- #t
(any? odd? '(2 4 6))    ;-- #f
(any? even? '())        ;-- #f
```

## 02. `(concat xss)`
Взима списък от списъци и ги слепя един за друг.

Примери:
```scheme
(concat '((1 2 3) (4 5 6) (7 8 9))) ;-- '(1 2 3 4 5 6 7 8 9)
(concat '())                        ;-- '()
(concat '(() () () () () () ()))    ;-- '()
```

## 03. `(rows xss)`
Връща редовете на матрица `xss` като списък.

Примери:
```scheme
(rows '((1 2 3)
        (4 5 6)
        (7 8 9))) ;-- '((1 2 3) (4 5 6) (7 8 9))
```

## 04. `(cols xss)`
Връща колоните на матрица `xss` като списък.

Примери:
```scheme
(cols '((1 2 3)
        (4 5 6)
        (7 8 9))) ;-- '((1 4 7) (2 5 8) (3 6 9))
```
**Hint:** `car` и `cdr` взимат главата/опашката на един списък. Как можем да вземем главата/опашката на **всеки** елемент на даден списък?

## 05. `(matrix-ref xss i j)`
Индексира матрица `xss`, както индексираме и списък. Само дето с два индекса, очевидно.
Тоест връща `j`-тия елемент от `i`-тия ред на `xss`. Индексите започват от `0`.

Примери:
```scheme
(matrix-ref '((1 2 3)
              (4 5 6)
              (7 8 9)) 1 1) ;-- 5
(matrix-ref '((1 2 3)
              (4 5 6)
              (7 8 9)) 1 0) ;-- 4
(matrix-ref '((1 2 3)
              (4 5 6)
              (7 8 9)) 0 2) ;-- 3
```
**Hint**: Имате вече функция за индексирне на списъци.

## 06. `(set xs i x)`
Връща списък, който е същият като `xs`, само че на индекс `i` седи елементът `x`.

Примери:
```scheme
(set '(1 2 3) 2 1337)   ;-- '(1 2 1337)
(set '(1 2 3 4 5) 0 42) ;-- '(42 2 3 4 5)
```

## 07. `(place xss i j x)`
Връща матрица, която е същата като матрицата `xss`, само че на индекс `i` `j` седи елементът `x`.

Примери:
```scheme
(place '((1 2 3)
         (4 5 6)
         (7 8 9)) 1 1 42)   ;-- '((1 2 3)
                            ;     (4 42 6)
                            ;     (7 8 9))
(place '((1 2 3)
         (4 5 6)
         (7 8 9)) 1 0 69)   ;-- '((1 2 3)
                            ;     (69 5 6)
                            ;     (7 8 9))
(place '((1 2 3)
         (4 5 6)
         (7 8 9)) 0 2 1337) ;-- '((1 2 1337)
                            ;     (4 5 6)
                            ;     (7 8 9))
```
**Hint**: Вече имате функция която сменя елемент на списък.

## 08. `(diag xss)`
Връща главния диагонал на матрица `xss`.

Примери:
```scheme
(diag '((1 2 3)
        (4 5 6)
        (7 8 9))) ;-- '(1 5 9)
(diag '((1))) ;-- '(1)
(diag '((1 0)
        (0 1))) ;-- '(1 1)
```

## 09. `(diags xss)`
Връща и двата диагонала на `xss`.

Примери:
```scheme
(diags '((1 0)
         (0 1)))   ;-- '((1 1) (0 0))
(diags '((1 2 3)
         (4 5 6)
         (7 8 9))) ;-- '((1 5 9) (3 5 7))
```
**Hint**: Можем да "flip-нем" матрицата или вертикално, или хоризонтално, и след това просто да викнем `diag` на нея.

## 10. `(map-matrix f xss)`
Прилага `f` на всеки елемент на матрицата `xss` и връща преобразуваната матрица. Като за списъци.

Примери:
```scheme
(define (1+ x) (+ 1 x))
(define (id x) x)
(define (const x) (lambda (y) x))

(map-matrix id         '((1337)))  ;-- '((1337))
(map-matrix 1+         '((1 0)
                         (0 1)))   ;-- '((2 1)
                                   ;     (1 2))
(map-matrix (const 69) '((1 2 3)
                         (4 5 6)
                         (7 8 9))) ;-- '((69 69 69)
                                   ;     (69 69 69)
                                   ;     (69 69 69))
```
**Hint:** Използвайте `map` за реализацията на `map-matrix`.

## 11. `(filter-matrix p? xss)`
Оставя само елементите на матрицата `xss`, които изпълняват предиката `p?`.
Забележете, че резултатът на тази функция не е матрица в общия случай.

Примери:
```scheme
(filter-matrix odd?  '((1 2 3)
                       (4 5 6)
                       (7 8 9))) ;-- '((1 3) (5) (7 9))
(filter-matrix zero? '((1 0)
                       (0 1)))   ;-- '((0) (0))
(filter-matrix zero? '((1 2 3)
                       (4 5 6)
                       (7 8 9))) ;-- '(() () ())
```

## 12. `(zip-with f xs ys)`
Прилага покомпонентно `f` върху елементите на списък `xs` и списък `ys` и връща списък с резултатите.
Ако някой от списъците е по-къс отрязва и по-дългия до дължината на по-късия.

Примери:
```scheme
(zip-with cons '(1 2 3) '(4 5 6))              ;-- '((1 . 4) (2 . 5) (3 . 6))
(zip-with cons '(1) '(4 5 6))                  ;-- '((1 . 4))
(zip-with + '(60 1300 40) '(9 37 2))           ;-- '(69 1337 42)
(zip-with string-append '("y" "y") '("o" "o")) ;-- '("yo" "yo")
```

## 13. `(zip-matrix xss yss)`
Прави нова матрица, която съдържа като елементи наредени двойки, покомпонентно елементите на матрица `xss` и на матрица `yss`.

Примери:
```scheme
(zip-matrix '((1 2))
            '((3 4))) ;-- '(((1 . 3) (2 . 4)))
(zip-matrix '((1 0)
              (0 1))
            '((6 9)
              (9 6))) ;-- '(((1 . 6) (0 . 9))
                      ;     ((0 . 9) (1 . 6)))
```
**Hint:** Използвйате `zip-with` (и `zip` - `zip-with cons`) за реализацията на `zip-matrix`.
